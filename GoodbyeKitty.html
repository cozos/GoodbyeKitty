<!DOCTYPE html>
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->

<head>
    <script type="text/javascript" src="http://cdn.craftycomponents.com/crafty-release.js"></script>
  	<script type="text/javascript" src='js/Background.js'></script>
  	<script type="text/javascript" src='js/Fuzzle.js'></script>
  	<script type="text/javascript" src='js/Keyboard.js'></script>
  	<script type="text/javascript" src='js/Trail.js'></script>
  	<script type="text/javascript" src='js/Obstacle.js'></script>
	<script type="text/javascript" src='js/LevelDirector.js'></script>
	<script type="text/javascript">

	//Window variables
	var windowWidth;
	var windowHeight;
	var tempWidthRatio;
	var tempHeghtRatio;
	var g_resize = 0.9;

	//Shit I don't understand
	var g_canvas;
	var g_foreground;
	var g_background;
	var g_context;

	//Fuzzle
	var g_fuzzle;
	
	//Intervals
	var g_renderInterval;
	var g_clockInterval;
	var g_inputInterval;
	var g_createObstacleInterval;
	var g_powerupInterval;
	var g_checkCollisionInterval;
	var gametimer;
	
	//Object arrays
	var g_trail = [];
	var g_obstacle = [];

	//Keys arrays
	var g_keys = [];
	var g_mouseDown = false;

	//Background Level Manager (level increases when timer is a multiple of transition, function will be called in Repaint)
	var g_levelDirector;
	var g_gameState = "mainmenu";

	//Audio manager
	var g_audioLoop;
	
	/**
 	* It's the main.
 	*/
	function main(){
		//Initializes main screen, key controls. Game start event is handled by mousedown event
		initCanvas();
		g_background = new Background("gamestart",0);
		g_background.render();
		document.addEventListener('keydown', keyDown, false);
		document.addEventListener('keyup', keyUp, false);
		document.addEventListener('mousedown', mouseDown, false);
		document.addEventListener('mouseup', mouseUp, false);
		g_audioLoop = document.getElementById("nyan_cat");
		g_audioLoop.volume = 0;
	}
	
	/**
 	* Initializes the canvas.
 	*/
	function initCanvas(){
	g_canvas = document.getElementById('theCanvas');
	g_context = g_canvas.getContext('2d');
	
	//Gets the innerWidth and innerHeight of browser and stores the minimum ratio to g_resize, subsequently resizing g_canvas
	windowWidth = window.innerWidth;
	windowHeight = window.innerHeight;
	tempWidthRatio = windowWidth / g_canvas.width;
	tempHeightRatio = windowHeight / g_canvas.height;
	g_resize = Math.min(tempWidthRatio,tempHeightRatio);
	g_canvas.width *= g_resize;
	g_canvas.height *= g_resize;
	}
	
	function renderLoop()
	{ 
	//if ( g_paused )
	//return;

	g_background.render();
	g_foreground.render();
	g_fuzzle.render();
	renderArray(g_trail);
	// introduce enemy
	renderArray(g_obstacle);
	renderHUD();
	}

	function inputLoop()
	{
		// Makes fuzzle jump up whenever a key is pressed
		mouse();
		keyboard();
	}

	function renderHUD()
	{
            g_context.fillStyle = "black";
            g_context.fillText("Lives: " + g_fuzzle.lives,10,10);
            g_context.fillText("Powerups: " + g_fuzzle.powerUp + "/9",10,20);
            g_context.fillText("Time Elapsed: " + (g_levelDirector.myClock/10),10,30);
	}

	// Check for collisions
	function collision(){
	collision_singleVSarray(g_fuzzle,g_obstacle);
	}

	/*
	 * Stores keys pressed into an object array(g_keys[]) and remove them from the array when the keys are released
	 */
	function keyDown(e)
	{
		g_keys[e.keyCode] = true;
		//e.preventDefault();
	}
	
	function keyUp(e)
	{
		delete g_keys[e.keyCode];
		//e.preventDefault();
	}

	function mouseDown()
	{
		if (g_gameState == "mainmenu")
		{
			g_levelDirector = new LevelDirector();
			g_levelDirector.startLevel();
		}
		else if (g_gameState == "inlevel")
		{
			g_mouseDown = true;
		}
		//else if (g_gameState == "gameover")
		//{
		//	g_audioLoop.play();
		//}
	}
	
	function mouseUp()
	{
		g_mouseDown = false;
	}

	function mouse()
	{
		if (g_mouseDown == true) //check if mouse is pressed
		{
			g_fuzzle.up();	
		}
	}
	
	/*
	 * Checks if a singular object collides with an array of objects 
	 */
	function collision_singleVSarray(single, array){
		for(var i = 0; i < array.length; i++){
			checkCollision(single,array[i],1);
		}
	}
	
	/*
	 * Checks if an array of objects with another array of objects 
	 */
	function collision_arrayVSarray(array, array){
		// TODO
	}
	
	/**
 	* Checks for collision between two objects.
    * @param Fuzzle|Obstacle|Trail $object1
    *       The first object to be checked for collision.
    * 
    * @param Fuzzle|Obstacle|Trail $object2
    *       The second object to be checked for collision.
    * 
    * @param int $fuzzle
    *       Set as 1 if you are checking if Fuzzle collides into something. This is because Fuzzle's hitbox is kind of fucked up, so it has to be adjusted a little.
 	*/
 	
 	function checkCollision(object1, object2,fuzzle){
 		// Defines hitbox parameters
 		var lower_x_1 = object1.posx;
 		var upper_x_1 = object1.posx + object1.width;
 		
 		var lower_y_1 = object1.posy;
 		var upper_y_1 = object1.posy + object1.height;
 		
 		var lower_x_2 = object2.posx;
 		var upper_x_2 = object2.posx + object2.width;
 		
 		var lower_y_2 = object2.posy;
 		var upper_y_2 = object2.posy + object2.height;
 		
 		// Adjusts hitbox for fuzzle
 		if (fuzzle == 1){
 			lower_x_1 += 60;
 			upper_x_1 += -60;
 			lower_y_1 += 50;
 			upper_y_1 += -40;
 		}
 		
 		// If the objects intersect, call collide.
 		if ( (((lower_x_1 > lower_x_2) && (lower_x_1 < upper_x_2)) || ((upper_x_1 > lower_x_2) && (upper_x_1 < upper_x_2))) &&
 			 (((lower_y_1 > lower_y_2) && (lower_y_1 < upper_y_2)) || ((upper_y_1 > lower_y_2) && (upper_y_1 < upper_y_2)))){
 			object1.collided();
 			object2.collided();
 		}
 	}
	
	/**
 	* Iterates through the object array and renders each one.
 	*/
	function renderArray(array){
		for (var j=0; j<array.length; j++){
			// If the object past the left of the screen, it is deleted.
			if(array[j].posx < -50){
			array.splice(j,1);
			}
			
			// Renders the object
			array[j].render();
		}
	}
	
	/**
 	* Creates an obstacle. Called by g_createObstacleInterval.
 	*/
	function createObstacle() 
	{
	var d;
	
	/**
 	* Determines randomly (if 0 then devil, if 1,2 then pillar) which obstacle to instantiate.
 	*/
	if (Math.round(Math.random()*1.5) == 0) d = new obstacle("devil",-7);
	else d = new obstacle("pillar",-5);
	
	// Instantiates new Obstacle
	g_obstacle.push(d);
	
	// Resets the interval for the next obstacle creation. This is so that obstacles appear randomly
	clearInterval(g_createObstacleInterval); 
	var x = Math.round(Math.random() * 1000) + 2000 - ((g_levelDirector.myCurrentLevel) * 800); 
	g_createObstacleInterval = setInterval(createObstacle, x);
	}  
	
	/**
	* Stops the game
	*/
	function stop(){
		g_gameState = "gameover";

		clearInterval(g_inputInterval);
		clearInterval(g_renderInterval);
		clearInterval(g_powerupInterval);
		clearInterval(g_clockInterval);
		clearInterval(g_createObstacleInterval);
		clearInterval(g_checkCollisionInterval);
		g_background = new Background("gameover",0);
		g_background.render();
	}
	</script>
  
</head>

<body onload = "main()">
	
	 <canvas align="left" id="theCanvas" width="960" height="640">empty</canvas>
	 <div id="hidden" style="visibility:hidden; width:1px; height:1px; overflow:hidden">
	
    <img    id="cloud"
            src="Images/cloud overlay.png">	
	
    <img    id="sky"
            src="Images/sky.png">
            
    <img    id="fuzzle"
            src="Images/freshfuzzle2.png">

    <img    id="powerup"
            src="Images/heart.png">
            
    <img    id="trail"
            src="Images/Fart.png">
            
    <img    id="firetrail"
            src="Images/FieryFart.png">
        
    <img    id="devil"
            src="Images/devil.png">
            
    <img    id="pillar"
            src="Images/pillar.png">

    <img    id="gamestart"
            src="Images/gamestart.png">            

    <img    id="gameover"
            src="Images/gameover.png">
            
    <audio  id="nyan_cat" 
            src="Audio/Fresh_Prince_of_Bel_air.ogg"
            autobuffer='true'>
    </audio>
            
	 </div>
</body>
</html>
